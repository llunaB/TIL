# ì¬ê·€

> í•¨ê»˜ í•™ìŠµí•˜ê³  ê³ ë¯¼í•˜ê³  ì„¤ëª…í•˜ë©° ì‘ì€ ë¶€ë¶„ í•˜ë‚˜ë¼ë„ 'ë‚´ ê²ƒ'ìœ¼ë¡œ ë§Œë“¤ì–´ë³´ì„¸ìš”. ğŸ˜




## 2ë²ˆ - Merge Sort Time Complexity Proof

- Merge Sortê°€ ì§„í–‰ë˜ëŠ” ê³¼ì •ì„ ì§ì ‘ ê·¸ë ¤ë³´ê³  ê° ë‹¨ê³„ì—ì„œ ì–´ë–¤ ì¼ì´ ì¼ì–´ë‚˜ëŠ”ì§€ ìƒê°í•´ë³´ì„¸ìš”.
- ê¸°ì´ˆ ìˆ˜ì‹ì—ì„œ í•™ìŠµí•œ ì¬ê·€ì‹ìœ¼ë¡œ í‘œí˜„í•˜ë©´ ì–´ë–»ê²Œ ë˜ëŠ”ì§€ ê°™ì´ ìƒê°í•´ë³´ì„¸ìš”.

![ì¬ê·€_2](5_ì¬ê·€.assets/ì¬ê·€_2.PNG)

##### solution

```python
#Merge Sort
arr = [] #ì •ë ¬í•  ë¦¬ìŠ¤íŠ¸

def merge_sort(arr):
    def sort(low, high):
        if low < high:
            mid = (low+high)//2
            sort(low,mid)
            sort(mid,high)
            merge(low, mid, high)
        else:
            return
        
     def merge(low, mid, high):
        tmp = []
        left, right = low, mid
        
        while left < mid and right < high:
            if arr[left] < arr[right]:
                tmp.append(arr[left])
                left += 1
            else:
                tmp.append(arr[right])
                right += 1
                
        while left < mid:
            tmp.append(arr[left])
            left += 1
            
        while right > mid:
            tmp.append(arr[right])
            right += 1
        
        for i in range(low, high):
            arr[i] = tmp[i - low]
        
        return sort(0, len(arr))
```

```python
#merge_sort ê³¼ì •(len(arr)=8ì¸ ê²½ìš°)
1.merge_sort(arr)
	2.sort(0,len(arr))
    	3.sort(0, 4)
        	4.sort(0, 2)
            	5-1.sort(0, 1) => return
            	5-2.sort(1, 2) => return
            6.merge(0,1,2)###
            7.sort(2,4)
            	8-1.sort(2,3) => return
            	8-2.sort(3,4) => return
            9.merge(2,3,4)###
        10.sort(4, 8)
        	11.sort(4, 6)
            	12-1.sort(4, 5) => return
            	12-2.sort(5, 6) => return
            13.sort(6, 8)
            	14-1.sort(6, 7) => return
            	14-2.sort(7, 8) => return
            15.merge(6, 7, 8)###
        16.merge(0, 4, 8)###
```

**ì‹œê°„ë³µì¡ë„**
$$
T(n)=2T({n \over 2})+n, \quad T(1)=1\\
T(n)=2(T({n \over 2})+(n/2))\\
T(n)=2(2(T({n \over 4})+({n \over 4}))+(n/2))\\
...\\
T(n)=2(2(2(2(2(...(2(T(1)+1)+2)...)+({n \over 16}))+({n \over 8}))+({n \over 4}))+({n \over 2}))\\
T(n)=n+nlog_2n\\
ì‹œê°„ë³µì¡ë„ =O(nlog_2n)
$$




## 4ë²ˆ 

![image-20210925231537705](5_ì¬ê·€.assets/image-20210925231537705.png)

**ë¬¸ì œ3ì˜ Sorting ì•Œê³ ë¦¬ì¦˜**

##### ![image-20210928142710288](5_ì¬ê·€.assets/image-20210928142710288.png)

##### solution

ëª¨ë¥´ê² ì–´ìš”...



## 6ë²ˆ

![image-20210926214721791](5_ì¬ê·€.assets/image-20210926214721791.png)

##### solution

```python
graph = [[]] #2ì°¨ì› ë°°ì—´ ê°€ì •
visited = []
def dfs(graph, start, visited):
    visited.append(start)
    for child in graph[start]:
        if child == 1:
            visited.append(child)
            dfs(graph, child, visited)
    return visited
#ì¶œë ¥ êµ¬í˜„ì€ ëª»í–ˆìŠµë‹ˆë‹¤...
```




## ì°¸ê³ ìë£Œ

http://www.bowdoin.edu/~ltoma/teaching/cs231/fall16/Lectures/02-recurrences/recurrences.pdf

https://www.cs.princeton.edu/courses/archive/spr07/cos226/lectures/04MergeQuick.pdf